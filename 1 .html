<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”Ÿæ­»ä¹‹èµŒï¼ˆç‚¼ç‹±ç‰ˆï¼‰</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Arial Black", sans-serif;
        }
        body {
            background: #0f0f0f;
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
        }
        .game-title {
            font-size: 3rem;
            color: #ff4444;
            text-shadow: 0 0 15px rgba(255,68,68,0.8);
            letter-spacing: 2px;
        }
        .btn {
            padding: 1rem 2rem;
            font-size: 1.2rem;
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 0 rgba(0,0,0,0.2), 0 0 10px rgba(255,255,255,0.1);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 0 rgba(0,0,0,0.2);
        }
        .btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            transition: left 0.4s ease;
        }
        .btn:hover::after {
            left: 100%;
        }
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 0 #444;
        }
        .btn:disabled::after {
            display: none;
        }
        .enter-battle-btn {
            background: #44ff44;
            color: #000;
            font-weight: bold;
            box-shadow: 0 4px 0 #33cc33, 0 0 15px rgba(68,255,68,0.6);
        }
        .enter-battle-btn:hover {
            background: #33cc33;
            box-shadow: 0 6px 0 #22aa22, 0 0 20px rgba(68,255,68,0.8);
        }
        .panel {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            background: #1a1a1a;
            padding: 2rem;
            border-radius: 12px;
            border: 2px solid #ff4444;
            width: 90%;
            max-width: 600px;
        }
        .panel.active {
            display: flex;
            animation: panelFade 0.3s ease;
        }
        @keyframes panelFade {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .loading-panel {
            gap: 1.2rem;
        }
        .loading-text {
            font-size: 1.2rem;
            color: #44ddff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .loading-text span {
            animation: blink 1s infinite;
        }
        .loading-text span:nth-child(2) { animation-delay: 0.2s; }
        .loading-text span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .skill-loading-text {
            font-size: 1rem;
            color: #ffccdd;
            margin-top: 0.5rem;
        }
        .hp-container {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 100%;
        }
        .hp-card {
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
            border-radius: 8px;
            background: #222;
            position: relative;
        }
        .emoji-feedback {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.8rem;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.3s ease;
        }
        .emoji-feedback.show {
            opacity: 1;
            transform: translateY(-50%) scale(1.2);
        }
        .skill-display {
            font-size: 1rem;
            color: #ffccdd;
            font-style: italic;
            height: 2.4rem; /* é€‚é…ä¸¤è¡ŒæŠ€èƒ½æ˜¾ç¤º */
        }
        .hp-title {
            font-size: 1.5rem;
            color: #ffdd44;
        }
        .hp-display {
            font-size: 2.2rem;
            letter-spacing: 6px;
            padding: 0.5rem 0;
        }
        .turn-tip {
            font-size: 1.3rem;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            height: 2.5rem;
            text-align: center;
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 6px;
            background-image: linear-gradient(to right, #8b0000, #b22222, #8b0000);
            background-size: 200% auto;
            animation: gradientMove 3s ease infinite;
            width: 100%;
        }
        @keyframes gradientMove {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .skill-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            width: 100%;
        }
        .skill-btn {
            padding: 1rem;
            background: #2a2a2a;
            border: 2px solid #44ddff;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }
        .skill-btn:hover {
            background: #3a3a3a;
            border-color: #44ffaa;
            transform: translateX(5px);
        }
        .skill-selected {
            background: #3a3a3a;
            border-color: #44ffaa;
            box-shadow: 0 0 10px rgba(68,255,170,0.5);
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
        .modal.active {
            display: flex;
        }
        .modal-content {
            background: #1a1a1a;
            padding: 3rem 4rem;
            border-radius: 12px;
            border: 2px solid #ff4444;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            transform: scale(0.8);
            opacity: 0;
            transition: all 0.3s ease;
        }
        .modal.active .modal-content {
            transform: scale(1);
            opacity: 1;
        }
        .fail-text {
            font-size: 2.5rem;
            color: #ff4444;
        }
        .win-text {
            font-size: 2.5rem;
            color: #44ff44;
            text-shadow: 0 0 15px rgba(68,255,68,0.8);
        }
        .attack-btn-group {
            display: flex;
            gap: 1rem;
            width: 100%;
            justify-content: center;
        }
        @keyframes hitShake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-3px); }
            80% { transform: translateX(3px); }
        }
        .hit-shake {
            animation: hitShake 0.3s ease;
        }
        @keyframes reviveGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(68,255,68,0.5); }
            50% { box-shadow: 0 0 20px rgba(68,255,68,0.8); }
        }
        .revive-glow {
            animation: reviveGlow 1s ease;
        }
        /* å›å¤ç‰¹æ•ˆï¼šç»¿è‰²è„‰å†²ï¼ˆç©å®¶+å¯¹æ‰‹é€šç”¨ï¼‰ */
        @keyframes healPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(68,255,68,0.6); }
            50% { box-shadow: 0 0 25px rgba(68,255,68,0.9); }
        }
        .heal-pulse {
            animation: healPulse 1s ease;
        }
        .skill-select-tip {
            font-size: 1rem;
            color: #ffdd44;
            margin-top: -1rem;
        }
        /* è¡ŒåŠ¨æ¬¡æ•°æç¤ºæ ·å¼ */
        .action-count {
            font-size: 1rem;
            color: #44ddff;
            margin-top: 0.5rem;
        }
    </style>
</head>
<body>
    <h1 class="game-title">ç”Ÿæ­»ä¹‹èµŒï¼ˆç‚¼ç‹±ç‰ˆï¼‰</h1>
    <button id="startBtn" class="btn" style="background: #ff4444;">å¼€å§‹èµŒå±€</button>
    <div id="purgatoryPanel" class="panel">
        <h2>ç‚¼ç‹±æ¨¡å¼ - æé™æŒ‘æˆ˜</h2>
        <p style="text-align:center; color:#ffccdd;">å¯¹æ‰‹åˆå§‹2æŠ€èƒ½ | <b>å¯¹æ‰‹æ”»å‡»å‘½ä¸­å70%æ¦‚ç‡å›2â¤ï¸</b> | ç©å®¶æ”»å‡»è‡ªå·±1/6ä¸­ | <b>ç©å®¶â¤ï¸å…¨æ‰£å®Œ50%å¤æ´»</b> | å¯¹æ‰‹æ”»ç©å®¶70%ä¸­ | <b>ç©å®¶åŸºç¡€ç”Ÿå‘½5â¤ï¸</b> | <b>ç©å®¶åŸºç¡€ä¼¤å®³2â¤ï¸</b> | å¯¹æ‰‹åŸºç¡€ç”Ÿå‘½6â¤ï¸ | å¯¹æ‰‹åŸºç¡€ä¼¤å®³2â¤ï¸ | <b>æ”»å‡»è‡ªå·±æœªå‘½ä¸­+1è¡ŒåŠ¨ï¼ŒåŒä¸€æ–¹æœ€å¤š2æ¬¡ï¼Œè¾¾ä¸Šé™åˆ‡å›åˆ</b> | <b>ç©å®¶æ–°å¢å›å¤é”®ï¼ˆå 1æ¬¡è¡ŒåŠ¨ï¼‰</b></p>
        <button id="enterSkillSelectBtn" class="btn" style="background: #ffaa00; color:#000;">è¿›å…¥æŠ€èƒ½é€‰æ‹©</button>
    </div>
    <div id="playerSkillPanel" class="panel">
        <h2>ä½ çš„æŠ€èƒ½é€‰æ‹©ï¼ˆé€‰2ä¸ªï¼‰</h2>
        <p class="skill-select-tip">å¯é€‰æ‹©ä¸åŒæŠ€èƒ½ï¼Œæ•ˆæœå åŠ ç”Ÿæ•ˆ</p>
        <div class="skill-grid">
            <button class="skill-btn" data-skill="extraHp">1. å¤šä¸€ä¸ªâ¤ï¸ï¼ˆåˆå§‹ç”Ÿå‘½å€¼+1ï¼‰</button>
            <button class="skill-btn" data-skill="shield">2. æŠ¤ç›¾ï¼ˆæ— è§†ä¸€æ¬¡ä¸­å¼¹ä¼¤å®³ï¼‰</button>
            <button class="skill-btn" data-skill="extraDmg">3. è‡´å‘½ä¸€å‡»ï¼ˆæ”»å‡»å‘½ä¸­æ—¶å¤šæ‰£1â¤ï¸ï¼‰</button>
        </div>
        <button id="confirmPlayerSkill" class="btn" disabled style="background: #44ddff; color: #000;">ç¡®è®¤é€‰æ‹©ï¼ˆå·²é€‰ï¼š0/2ï¼‰</button>
    </div>
    <div id="enemySkillLoadingPanel" class="panel loading-panel">
        <h2>å¯¹æ‰‹æ­£åœ¨åŠ è½½åŒæŠ€èƒ½</h2>
        <div class="loading-text">
            åˆ†ææˆ˜å±€ä¸­<span>.</span><span>.</span><span>.</span>
        </div>
        <div class="skill-loading-text" id="enemySkillLoadingText">å¯¹æ‰‹æŠ€èƒ½1ï¼šéšæœºä¸­...<br>å¯¹æ‰‹æŠ€èƒ½2ï¼šéšæœºä¸­...</div>
        <button id="enterBattleBtn" class="btn enter-battle-btn" disabled>è¿›å…¥æˆ˜å±€</button>
    </div>
    <div id="gamePanel" class="panel">
        <div class="hp-card">
            <span id="enemySkillDisplay" class="skill-display">æŠ€èƒ½1ï¼šæ— <br>æŠ€èƒ½2ï¼šæ— </span>
            <div class="hp-title">å¯¹æ‰‹ç”Ÿå‘½å€¼</div>
            <div id="enemyHp" class="hp-display">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div> <!-- å¯¹æ‰‹åˆå§‹6â¤ï¸ -->
            <div id="enemyShield" class="hp-title" style="color: #44ddff; display: none;">æŠ¤ç›¾ï¼š1</div>
            <div id="enemyEmoji" class="emoji-feedback">ğŸ˜¡</div>
        </div>
        <div class="hp-card">
            <span id="playerSkillDisplay" class="skill-display">æŠ€èƒ½1ï¼šæ— <br>æŠ€èƒ½2ï¼šæ— </span>
            <div class="hp-title">ä½ çš„ç”Ÿå‘½å€¼</div>
            <div id="playerHp" class="hp-display">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</div> <!-- ç©å®¶åˆå§‹5â¤ï¸ -->
            <div id="playerShield" class="hp-title" style="color: #44ddff; display: none;">æŠ¤ç›¾ï¼š1</div>
            <div id="playerEmoji" class="emoji-feedback">ğŸ˜¡</div>
        </div>
        <!-- è¡ŒåŠ¨æ¬¡æ•°æç¤ºï¼ˆæ˜ç¡®ä¸Šé™ï¼‰ -->
        <div class="action-count" id="actionCountTip">å½“å‰å›åˆè¡ŒåŠ¨æ¬¡æ•°ï¼š0/1ï¼ˆä¸Šé™2æ¬¡ï¼‰</div>
        <!-- å›å¤é”® -->
        <div class="attack-btn-group">
            <button id="attackSelfBtn" class="btn" style="background: #ff4444;">æ”»å‡»è‡ªå·±</button>
            <button id="attackEnemyBtn" class="btn" style="background: #44aa44;">æ”»å‡»å¯¹æ‰‹</button>
            <button id="healBtn" class="btn" style="background: #44ff88; color: #000;">å›å¤ç”Ÿå‘½</button>
        </div>
        <div class="turn-tip" id="turnTip">å›åˆå¼€å§‹ï¼éšæœºå…ˆæ‰‹...</div>
    </div>
    <div id="failModal" class="modal">
        <div class="modal-content">
            <div class="fail-text">èœï¼ç‚¼ç‹±æ¨¡å¼éƒ½æ‰“ä¸è¿‡</div>
            <button id="restartBtn" class="btn" style="background: #ff4444;">é‡æ–°èµŒå±€</button>
        </div>
    </div>
    <div id="winModal" class="modal">
        <div class="modal-content">
            <div class="win-text">ç‰›ï¼ç‚¼ç‹±æˆ˜ç¥å°±æ˜¯ä½ </div>
            <button id="winRestartBtn" class="btn" style="background: #44aa44;">å†æ¥ä¸€å±€</button>
        </div>
    </div>
    <script>
        const gameState = {
            baseHp: 5, // ç©å®¶åŸºç¡€ç”Ÿå‘½5â¤ï¸
            enemyBaseHp: 6, // å¯¹æ‰‹åŸºç¡€ç”Ÿå‘½6â¤ï¸
            difficulty: 'purgatory',
            playerSkills: [],
            enemySkills: [],
            playerHp: 5, // ç©å®¶åˆå§‹ç”Ÿå‘½5â¤ï¸
            enemyHp: 6, // å¯¹æ‰‹åˆå§‹ç”Ÿå‘½6â¤ï¸
            playerShield: 0,
            enemyShield: 0,
            currentTurn: null, // å½“å‰è¡ŒåŠ¨æ–¹ï¼ˆplayer/enemyï¼‰
            hasExtraAttack: false, // ç©å®¶æ”»å‡»è‡ªå·±æœªå‘½ä¸­çš„é¢å¤–æ”»å‡»æœºä¼š
            attackCd: 1500,
            isSettling: false,
            hasRevived: false,
            currentActionCount: 0, // å½“å‰æ–¹å·²è¡ŒåŠ¨æ¬¡æ•°
            baseActionCount: 1, // æ¯æ–¹åŸºç¡€è¡ŒåŠ¨æ¬¡æ•°
            maxActionLimit: 2, // åŒä¸€æ–¹æœ€å¤šè¡ŒåŠ¨æ¬¡æ•°ï¼ˆä¸Šé™ï¼‰
            hasAddedAction: false // æ ‡è®°å½“å‰æ–¹æ˜¯å¦å·²è§¦å‘â€œæ”»å‡»è‡ªå·±æœªå‘½ä¸­+è¡ŒåŠ¨â€ï¼ˆé¿å…å¤šæ¬¡å åŠ ï¼‰
        };
        const skillNameMap = {
            extraHp: "å¤šä¸€ä¸ªâ¤ï¸",
            shield: "æŠ¤ç›¾ï¼ˆ1æ¬¡ï¼‰",
            extraDmg: "è‡´å‘½ä¸€å‡»",
            null: "æ— "
        };
        // DOMå…ƒç´ è·å–
        const startBtn = document.getElementById('startBtn');
        const purgatoryPanel = document.getElementById('purgatoryPanel');
        const playerSkillPanel = document.getElementById('playerSkillPanel');
        const enemySkillLoadingPanel = document.getElementById('enemySkillLoadingPanel');
        const gamePanel = document.getElementById('gamePanel');
        const failModal = document.getElementById('failModal');
        const winModal = document.getElementById('winModal');
        const enterSkillSelectBtn = document.getElementById('enterSkillSelectBtn');
        const playerSkillBtns = document.querySelectorAll('.skill-btn:not(.enemy-skill-btn)');
        const confirmPlayerSkill = document.getElementById('confirmPlayerSkill');
        const playerHpEl = document.getElementById('playerHp');
        const enemyHpEl = document.getElementById('enemyHp');
        const playerShieldEl = document.getElementById('playerShield');
        const enemyShieldEl = document.getElementById('enemyShield');
        const playerSkillDisplay = document.getElementById('playerSkillDisplay');
        const enemySkillDisplay = document.getElementById('enemySkillDisplay');
        const enemySkillLoadingText = document.getElementById('enemySkillLoadingText');
        const enterBattleBtn = document.getElementById('enterBattleBtn');
        const playerEmoji = document.getElementById('playerEmoji');
        const enemyEmoji = document.getElementById('enemyEmoji');
        const turnTip = document.getElementById('turnTip');
        const attackSelfBtn = document.getElementById('attackSelfBtn');
        const attackEnemyBtn = document.getElementById('attackEnemyBtn');
        const healBtn = document.getElementById('healBtn');
        const restartBtn = document.getElementById('restartBtn');
        const winRestartBtn = document.getElementById('winRestartBtn');
        const actionCountTip = document.getElementById('actionCountTip');

        function initEventListeners() {
            startBtn.addEventListener('click', () => {
                startBtn.style.display = 'none';
                purgatoryPanel.classList.add('active');
            });

            enterSkillSelectBtn.addEventListener('click', () => {
                purgatoryPanel.classList.remove('active');
                playerSkillPanel.classList.add('active');
            });

            playerSkillBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const selectedSkill = btn.dataset.skill;
                    if (gameState.playerSkills.includes(selectedSkill)) {
                        gameState.playerSkills = gameState.playerSkills.filter(skill => skill !== selectedSkill);
                        btn.classList.remove('skill-selected');
                    } else if (gameState.playerSkills.length < 2) {
                        gameState.playerSkills.push(selectedSkill);
                        btn.classList.add('skill-selected');
                    }
                    confirmPlayerSkill.disabled = gameState.playerSkills.length !== 2;
                    confirmPlayerSkill.textContent = `ç¡®è®¤é€‰æ‹©ï¼ˆå·²é€‰ï¼š${gameState.playerSkills.length}/2ï¼‰`;
                });
            });

            confirmPlayerSkill.addEventListener('click', () => {
                if (gameState.playerSkills.length !== 2) return;
                playerSkillPanel.classList.remove('active');
                enemySkillLoadingPanel.classList.add('active');
                randomEnemyDoubleSkills();
            });

            enterBattleBtn.addEventListener('click', () => {
                enemySkillLoadingPanel.classList.remove('active');
                initGame();
                gamePanel.classList.add('active');
            });

            attackSelfBtn.addEventListener('click', () => {
                if (gameState.currentTurn !== 'player' || gameState.isSettling || gameState.currentActionCount >= gameState.maxActionLimit) return;
                disableActionBtns();
                attackTarget('self');
            });

            attackEnemyBtn.addEventListener('click', () => {
                if (gameState.currentTurn !== 'player' || gameState.isSettling || gameState.currentActionCount >= gameState.maxActionLimit) return;
                const isExtra = gameState.hasExtraAttack;
                if (isExtra) gameState.hasExtraAttack = false;
                disableActionBtns();
                attackTarget('enemy', false, isExtra);
            });

            healBtn.addEventListener('click', () => {
                if (gameState.currentTurn !== 'player' || gameState.isSettling || gameState.currentActionCount >= gameState.maxActionLimit) return;
                disableActionBtns();
                playerHeal();
            });

            restartBtn.addEventListener('click', () => resetGame(failModal));
            winRestartBtn.addEventListener('click', () => resetGame(winModal));
        }

        function randomEnemyDoubleSkills() {
            const skills = ['extraHp', 'shield', 'extraDmg'];
            const skill1 = skills[Math.floor(Math.random() * skills.length)];
            let skill2;
            do {
                skill2 = skills[Math.floor(Math.random() * skills.length)];
            } while (skill2 === skill1);
            
            gameState.enemySkills = [skill1, skill2];
            const skill1Name = skillNameMap[skill1];
            const skill2Name = skillNameMap[skill2];
            setTimeout(() => {
                enemySkillLoadingText.textContent = `å¯¹æ‰‹æŠ€èƒ½1ï¼š${skill1Name}\nå¯¹æ‰‹æŠ€èƒ½2ï¼š${skill2Name}`;
                enterBattleBtn.disabled = false;
            }, 1500);
        }

        function disableActionBtns() {
            attackSelfBtn.disabled = true;
            attackEnemyBtn.disabled = true;
            healBtn.disabled = true;
        }

        function enableActionBtns() {
            if (gameState.currentTurn === 'player' && gameState.currentActionCount < gameState.maxActionLimit) {
                attackSelfBtn.disabled = false;
                attackEnemyBtn.disabled = false;
                healBtn.disabled = false;
            }
        }

        function initGame() {
            gameState.playerHp = gameState.baseHp;
            gameState.enemyHp = gameState.enemyBaseHp;
            gameState.playerShield = 0;
            gameState.enemyShield = 0;
            gameState.hasExtraAttack = false;
            gameState.isSettling = false;
            gameState.hasRevived = false;
            gameState.currentActionCount = 0;
            gameState.hasAddedAction = false;

            // ç©å®¶åŒæŠ€èƒ½ç”Ÿæ•ˆ
            gameState.playerSkills.forEach(skill => {
                if (skill === 'extraHp') gameState.playerHp += 1;
                if (skill === 'shield') {
                    gameState.playerShield = 1;
                    playerShieldEl.style.display = 'block';
                }
            });

            // å¯¹æ‰‹åŒæŠ€èƒ½ç”Ÿæ•ˆ
            gameState.enemySkills.forEach(skill => {
                if (skill === 'extraHp') gameState.enemyHp += 1;
                if (skill === 'shield' && gameState.enemyShield === 0) {
                    gameState.enemyShield = 1;
                    enemyShieldEl.style.display = 'block';
                }
            });

            // æ›´æ–°æŠ€èƒ½æ˜¾ç¤º
            const playerSkill1 = gameState.playerSkills[0] || null;
            const playerSkill2 = gameState.playerSkills[1] || null;
            playerSkillDisplay.textContent = `æŠ€èƒ½1ï¼š${skillNameMap[playerSkill1]}\næŠ€èƒ½2ï¼š${skillNameMap[playerSkill2]}`;
            enemySkillDisplay.textContent = `æŠ€èƒ½1ï¼š${skillNameMap[gameState.enemySkills[0]]}\næŠ€èƒ½2ï¼š${skillNameMap[gameState.enemySkills[1]]}`;
            
            updateHpDisplay();
            updateActionCountTip();
            hideAllEmojis();
            setTimeout(() => randomTurn(), 1000);
        }

        function randomTurn() {
            if (gameState.isSettling) return;
            gameState.currentTurn = gameState.currentTurn === null 
                ? (Math.random() > 0.5 ? 'player' : 'enemy') 
                : (gameState.currentTurn === 'player' ? 'enemy' : 'player');
            gameState.currentActionCount = 0;
            gameState.hasExtraAttack = false;
            gameState.hasAddedAction = false;
            
            updateActionCountTip();
            turnTip.textContent = gameState.currentTurn === 'player' 
                ? 'ä½ çš„å›åˆï¼é€‰æ‹©æ”»å‡»/å›å¤ç›®æ ‡' 
                : 'å¯¹æ‰‹çš„å›åˆï¼å‡†å¤‡æ”»å‡»è‡ªå·±/ä½ ...';

            if (gameState.currentTurn === 'enemy') {
                disableActionBtns();
                setTimeout(() => {
                    if (gameState.isSettling) return;
                    enemyTakeAction();
                }, 1500);
            } else {
                enableActionBtns();
            }
        }

        function enemyTakeAction() {
            if (gameState.currentActionCount >= gameState.maxActionLimit || gameState.isSettling) {
                setTimeout(() => randomTurn(), gameState.attackCd);
                return;
            }
            const enemyTarget = Math.random() < 0.1 ? 'self' : 'player';
            attackTarget(enemyTarget, true, false, (isHit, target) => {
                gameState.currentActionCount += 1;
                if (target === 'self' && !isHit && !gameState.hasAddedAction && gameState.currentActionCount < gameState.maxActionLimit) {
                    gameState.hasAddedAction = true;
                    turnTip.textContent = 'å¯¹æ‰‹æ”»å‡»è‡ªå·±æœªå‘½ä¸­ï¼è·å¾—é¢å¤–1æ¬¡è¡ŒåŠ¨';
                }
                updateActionCountTip();
                setTimeout(() => enemyTakeAction(), gameState.attackCd);
            });
        }

        // æ ¸å¿ƒä¿®æ”¹ï¼šå¯¹æ‰‹ä»…æ”»å‡»å‘½ä¸­å70%æ¦‚ç‡å›2â¤ï¸
        function attackTarget(target, isEnemy = false, isExtra = false, actionCallback = null) {
            if (gameState.isSettling) return;
            const attacker = isEnemy ? 'enemy' : 'player';
            const realTarget = target === 'self' ? attacker : (attacker === 'player' ? 'enemy' : 'player');
            let isHit = false;
            let actionResult = { isHit: false, target: target };

            // å‘½ä¸­æ¦‚ç‡ä¸å˜
            if (attacker === 'enemy') {
                if (realTarget === 'enemy') isHit = false;
                else isHit = Math.random() < 0.7;
            } else {
                if (realTarget === 'player') isHit = Math.random() < 1/6;
                else isHit = Math.random() < 1/2;
            }
            actionResult.isHit = isHit;

            hideAllEmojis();
            if (isHit) {
                // ä¼¤å®³è®¡ç®—ï¼šç©å®¶/å¯¹æ‰‹åŸºç¡€ä¼¤å®³å‡ä¸º2â¤ï¸
                let damage = attacker === 'enemy' ? 2 : 2;
                if (attacker === 'player' && gameState.playerSkills.includes('extraDmg')) damage = 3;
                if (attacker === 'enemy' && gameState.enemySkills.includes('extraDmg')) damage = 3;

                let isShieldUsed = false;
                // æŠ¤ç›¾æŠµæ¶ˆä¼¤å®³
                if (realTarget === 'player' && gameState.playerShield > 0) {
                    gameState.playerShield -= 1;
                    playerShieldEl.style.display = 'none';
                    turnTip.textContent = isEnemy ? 'å¯¹æ‰‹æ”»å‡»ä½ ï¼æŠ¤ç›¾æŠµæ¶ˆä¼¤å®³' : 'ä½ æ”»å‡»è‡ªå·±ï¼æŠ¤ç›¾æŠµæ¶ˆä¼¤å®³';
                    showEmoji('player', 'ğŸ˜…');
                    isShieldUsed = true;
                } else if (realTarget === 'enemy' && gameState.enemyShield > 0) {
                    gameState.enemyShield -= 1;
                    enemyShieldEl.style.display = 'none';
                    enemySkillDisplay.textContent = `æŠ€èƒ½1ï¼š${skillNameMap[gameState.enemySkills[0]]}\næŠ€èƒ½2ï¼š${gameState.enemySkills.includes('shield') ? 'æŠ¤ç›¾ï¼ˆå·²æ¶ˆè€—ï¼‰' : skillNameMap[gameState.enemySkills[1]]}`;
                    turnTip.textContent = isEnemy ? 'å¯¹æ‰‹æ”»å‡»è‡ªå·±ï¼æŠ¤ç›¾æŠµæ¶ˆä¼¤å®³' : 'ä½ æ”»å‡»å¯¹æ‰‹ï¼æŠ¤ç›¾æŠµæ¶ˆä¼¤å®³';
                    showEmoji('enemy', 'ğŸ˜…');
                    isShieldUsed = true;
                }

                // æ‰£è¡€é€»è¾‘
                if (!isShieldUsed) {
                    gameState[`${realTarget}Hp`] -= damage;
                    const hpCard = document.querySelector(`#${realTarget}Hp`).parentElement;
                    hpCard.classList.add('hit-shake');
                    setTimeout(() => hpCard.classList.remove('hit-shake'), 300);

                    // æ”»å‡»æç¤º
                    if (attacker === 'player' && realTarget === 'enemy') {
                        showEmoji('enemy', 'ğŸ˜¡');
                        turnTip.textContent = `ä½ æ”»å‡»å¯¹æ‰‹ï¼å‘½ä¸­ï¼å¯¹æ‰‹æŸå¤±${damage}â¤ï¸`;
                    } else if (attacker === 'player' && realTarget === 'player') {
                        showEmoji('player', 'ğŸ˜¡');
                        turnTip.textContent = `ä½ æ”»å‡»è‡ªå·±ï¼å‘½ä¸­ï¼ä½ æŸå¤±${damage}â¤ï¸`;
                    } else if (attacker === 'enemy' && realTarget === 'player') {
                        showEmoji('player', 'ğŸ˜¡');
                        turnTip.textContent = `å¯¹æ‰‹æ”»å‡»ä½ ï¼å‘½ä¸­ï¼ä½ æŸå¤±${damage}â¤ï¸`;
                    }
                }

                // æ ¸å¿ƒä¿®æ”¹ï¼šä»…å¯¹æ‰‹æ”»å‡»å‘½ä¸­æ—¶ï¼ˆæ— è®ºæ˜¯å¦è§¦å‘æŠ¤ç›¾ï¼‰ï¼Œ70%æ¦‚ç‡å›2â¤ï¸
                if (attacker === 'enemy') {
                    const healRand = Math.random();
                    if (healRand < 0.7) { // 70%æ¦‚ç‡ï¼ˆåŒ¹é…è§„åˆ™æç¤ºï¼‰
                        gameState.enemyHp += 2; // å›2â¤ï¸
                        const enemyHpCard = document.querySelector('#enemyHp').parentElement;
                        enemyHpCard.classList.add('heal-pulse'); // å›è¡€ç‰¹æ•ˆ
                        setTimeout(() => enemyHpCard.classList.remove('heal-pulse'), 1000);
                        // å åŠ å›è¡€æç¤º
                        turnTip.textContent += ` | å¯¹æ‰‹å›è¡€2â¤ï¸`;
                        showEmoji('enemy', 'ğŸ¦‹'); // å›è¡€è¡¨æƒ…
                    }
                }

                updateHpDisplay();
                // èƒœè´Ÿåˆ¤å®š
                if (gameState.playerHp <= 0) {
                    if (!gameState.hasRevived && Math.random() < 0.5) {
                        gameState.hasRevived = true;
                        gameState.playerHp = 1;
                        updateHpDisplay();
                        const hpCard = document.querySelector('#playerHp').parentElement;
                        hpCard.classList.add('revive-glow');
                        setTimeout(() => hpCard.classList.remove('revive-glow'), 1000);
                        turnTip.textContent = 'ä½ ç”Ÿå‘½å€¼è€—å°½ï¼åœ¨æ˜¥ç§‹è‰å¸®åŠ©ä¸‹è§¦å‘å¤æ´»ï¼æ¢å¤1â¤ï¸';
                        
                        if (attacker === 'player') {
                            gameState.currentActionCount += 2;
                            updateActionCountTip();
                            setTimeout(() => {
                                enableActionBtns();
                                if (actionCallback) actionCallback(actionResult.isHit, actionResult.target);
                            }, gameState.attackCd);
                        } else {
                            setTimeout(() => {
                                if (actionCallback) actionCallback(actionResult.isHit, actionResult.target);
                            }, gameState.attackCd);
                        }
                        return;
                    }
                    gameState.isSettling = true;
                    setTimeout(() => failModal.classList.add('active'), 1000);
                    return;
                }
                if (gameState.enemyHp <= 0) {
                    gameState.isSettling = true;
                    setTimeout(() => winModal.classList.add('active'), 1000);
                    return;
                }
            } else {
                // æœªå‘½ä¸­é€»è¾‘ï¼šåˆ é™¤å¯¹æ‰‹æœªå‘½ä¸­æ—¶çš„å›è¡€ä»£ç ï¼Œä»…ä¿ç•™åŸæœ‰æç¤º
                if (attacker === 'player' && realTarget === 'player') {
                    showEmoji('player', 'ğŸ˜…');
                    gameState.hasExtraAttack = true;
                    if (!gameState.hasAddedAction && gameState.currentActionCount < gameState.maxActionLimit) {
                        gameState.hasAddedAction = true;
                        turnTip.textContent = 'ä½ æ”»å‡»è‡ªå·±æœªå‘½ä¸­ï¼è·å¾—é¢å¤–1æ¬¡è¡ŒåŠ¨+æ”»å‡»å¯¹æ‰‹æœºä¼š';
                    } else {
                        turnTip.textContent = 'ä½ æ”»å‡»è‡ªå·±æœªå‘½ä¸­ï¼è·å¾—é¢å¤–æ”»å‡»å¯¹æ‰‹æœºä¼š';
                    }
                } else if (attacker === 'player' && realTarget === 'enemy') {
                    showEmoji('enemy', 'ğŸ˜…');
                    turnTip.textContent = 'ä½ æ”»å‡»å¯¹æ‰‹ï¼æœªå‘½ä¸­ï¼';
                } else if (attacker === 'enemy' && realTarget === 'player') {
                    showEmoji('player', 'ğŸ˜…');
                    turnTip.textContent = 'å¯¹æ‰‹æ”»å‡»ä½ ï¼æœªå‘½ä¸­ï¼';
                    // ã€å·²åˆ é™¤ã€‘å¯¹æ‰‹æœªå‘½ä¸­æ—¶çš„å›è¡€é€»è¾‘
                } else if (attacker === 'enemy' && realTarget === 'enemy') {
                    showEmoji('enemy', 'ğŸ˜…');
                    turnTip.textContent = 'å¯¹æ‰‹æ”»å‡»è‡ªå·±ï¼æœªå‘½ä¸­ï¼';
                }
            }

            // è¡ŒåŠ¨åå¤„ç†ä¸å˜
            if (attacker === 'player') {
                gameState.currentActionCount += 1;
                updateActionCountTip();
                setTimeout(() => {
                    enableActionBtns();
                    if (gameState.currentActionCount >= gameState.maxActionLimit) {
                        setTimeout(() => randomTurn(), gameState.attackCd);
                    }
                }, gameState.attackCd);
            } else if (actionCallback) {
                actionCallback(actionResult.isHit, actionResult.target);
            }
        }

        // ç©å®¶å›å¤é€»è¾‘ä¸å˜
        function playerHeal() {
            if (gameState.isSettling) return;
            const healRand = Math.random();
            let healAmount = 0;
            if (healRand < 0.9) {
                healAmount = 2;
            } else if (healRand < 0.99) {
                healAmount = 3;
            } else {
                healAmount = 4;
            }

            gameState.playerHp += healAmount;
            const playerHpCard = document.querySelector('#playerHp').parentElement;
            playerHpCard.classList.add('heal-pulse');
            setTimeout(() => playerHpCard.classList.remove('heal-pulse'), 1000);

            updateHpDisplay();
            showEmoji('player', 'âœŒğŸ¤ âœŒ');
            turnTip.textContent = `å›å¤æˆåŠŸï¼æ¢å¤${healAmount}â¤ï¸`;

            gameState.currentActionCount += 1;
            updateActionCountTip();

            setTimeout(() => {
                enableActionBtns();
                if (gameState.currentActionCount >= gameState.maxActionLimit) {
                    setTimeout(() => randomTurn(), gameState.attackCd);
                }
            }, gameState.attackCd);
        }

        function updateActionCountTip() {
            actionCountTip.textContent = `å½“å‰å›åˆè¡ŒåŠ¨æ¬¡æ•°ï¼š${gameState.currentActionCount}/${gameState.maxActionLimit}ï¼ˆä¸Šé™${gameState.maxActionLimit}æ¬¡ï¼‰`;
        }

        function showEmoji(target, emoji) {
            const emojiEl = target === 'player' ? playerEmoji : enemyEmoji;
            emojiEl.textContent = emoji;
            emojiEl.classList.add('show');
            setTimeout(() => emojiEl.classList.remove('show'), 500);
        }

        function hideAllEmojis() {
            playerEmoji.classList.remove('show');
            enemyEmoji.classList.remove('show');
        }

        function updateHpDisplay() {
            playerHpEl.textContent = 'â¤ï¸'.repeat(Math.max(0, gameState.playerHp));
            enemyHpEl.textContent = 'â¤ï¸'.repeat(Math.max(0, gameState.enemyHp));
        }

        function resetGame(modal) {
            gameState.playerSkills = [];
            gameState.enemySkills = [];
            gameState.playerHp = gameState.baseHp;
            gameState.enemyHp = gameState.enemyBaseHp;
            gameState.playerShield = 0;
            gameState.enemyShield = 0;
            gameState.currentTurn = null;
            gameState.hasExtraAttack = false;
            gameState.isSettling = false;
            gameState.hasRevived = false;
            gameState.currentActionCount = 0;
            gameState.hasAddedAction = false;

            enterBattleBtn.disabled = true;
            enemySkillLoadingText.textContent = 'å¯¹æ‰‹æŠ€èƒ½1ï¼šéšæœºä¸­...<br>å¯¹æ‰‹æŠ€èƒ½2ï¼šéšæœºä¸­...';
            playerShieldEl.style.display = 'none';
            enemyShieldEl.style.display = 'none';
            modal.classList.remove('active');
            gamePanel.classList.remove('active');
            playerSkillBtns.forEach(b => b.classList.remove('skill-selected'));
            confirmPlayerSkill.disabled = true;
            confirmPlayerSkill.textContent = 'ç¡®è®¤é€‰æ‹©ï¼ˆå·²é€‰ï¼š0/2ï¼‰';
            playerSkillDisplay.textContent = 'æŠ€èƒ½1ï¼šæ— <br>æŠ€èƒ½2ï¼šæ— ';
            enemySkillDisplay.textContent = 'æŠ€èƒ½1ï¼šæ— <br>æŠ€èƒ½2ï¼šæ— ';
            turnTip.textContent = 'å›åˆå¼€å§‹ï¼éšæœºå…ˆæ‰‹...';
            updateActionCountTip();
            hideAllEmojis();

            setTimeout(() => startBtn.style.display = 'block', 300);
        }

        initEventListeners();
    </script>
</body>
</html>
